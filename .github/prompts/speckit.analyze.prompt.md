---
description: 在生成任务后，对 spec.md、plan.md、tasks.md 进行无破坏性的跨文档一致性与质量分析。
---

## 用户输入

```text
$ARGUMENTS
```

若用户输入不为空，你**必须**在继续前先进行考虑。

## 目标

在实施前，识别三份核心文档（`spec.md`、`plan.md`、`tasks.md`）中的不一致、重复、歧义以及描述不充分的内容。仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 之后才能运行本命令。

## 运行约束

**严格只读**：禁止修改任何文件。输出结构化的分析报告，可附带可选的整改方案（需用户明确同意后才可手动执行后续编辑命令）。

**宪章权威**：项目宪章（`.specify/memory/constitution.md`）在本分析范围内不可协商。若存在与宪章冲突的内容，必须标记为 CRITICAL，并要求调整 spec、plan 或 tasks，而非淡化、曲解或忽略原则。若需修改原则本身，必须在 `/speckit.analyze` 之外通过单独的宪章更新完成。

## 执行步骤

### 1. 初始化分析上下文

在仓库根目录运行一次 `.specify/scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks`，解析 JSON 中的 FEATURE_DIR 与 AVAILABLE_DOCS，并推导出以下绝对路径：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

若任一必需文件缺失，应立即报错，并提示用户先执行相应的前置命令。参数中若包含单引号（如 "I'm Groot"），请使用转义写法 'I'\''m Groot'，或尽量改用双引号 "I'm Groot"。

### 2. 渐进式加载文档

仅加载每份文档所需的最小上下文：

**来自 spec.md：**

- 概述 / 背景
- 功能需求
- 非功能需求
- 用户故事
- 边界情况（若存在）

**来自 plan.md：**

- 架构 / 技术栈选择
- 数据模型引用
- 各阶段规划
- 技术约束

**来自 tasks.md：**

- 任务 ID
- 任务描述
- 阶段分组
- 并行标记 [P]
- 涉及的文件路径

**来自宪章：**

- 加载 `.specify/memory/constitution.md` 以进行原则校验

### 3. 构建语义模型

创建内部表示（输出中不要直接粘贴原始文档内容）：

- **需求清单**：为每个功能与非功能需求建立稳定的键名（基于祈使句生成 slug，例如 “User can upload file” → `user-can-upload-file`）
- **用户故事 / 行为清单**：列出独立的用户操作及其验收标准
- **任务覆盖映射**：将每个任务关联到一个或多个需求或故事（可通过关键词、显式引用 ID 或关键短语推断）
- **宪章规则集**：提取原则名称以及 MUST/SHOULD 类的约束描述

### 4. 检测流程（兼顾 Token 效率）

聚焦高价值发现，总计不超过 50 条，其余合并至溢出摘要。

#### A. 重复检测

- 识别近似重复的需求
- 标记质量较低的表述以便后续合并

#### B. 歧义检测

- 标记缺乏量化标准的模糊形容词（如 fast、scalable、secure、intuitive、robust）
- 标记尚未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）

#### C. 描述不足

- 仅有动词却缺少对象或可衡量结果的需求
- 缺乏验收标准映射的用户故事
- 引用 spec/plan 中未定义文件或组件的任务

#### D. 宪章对齐

- 任一需求或计划元素若与 MUST 原则冲突
- 遗漏宪章要求的章节或质量门槛

#### E. 覆盖缺口

- 没有任何任务关联的需求
- 未映射到需求 / 故事的任务
- 未在任务中体现的非功能需求（如性能、安全性）

#### F. 不一致

- 术语漂移（同一概念在不同文件中的命名不一致）
- plan 中引用但 spec 中缺失的数据实体（或反之）
- 任务顺序矛盾（例如未注明依赖却先执行集成任务）
- 互相冲突的需求（如一个要求 Next.js，另一个指定 Vue）

### 5. 严重级别划分

使用以下启发式来确定优先级：

- **CRITICAL**：违反宪章 MUST、缺失核心规格文档、或阻塞基础功能且完全无任务覆盖的需求
- **HIGH**：重复或互相冲突的需求、模糊的安全/性能属性、不可验证的验收标准
- **MEDIUM**：术语漂移、非功能需求缺乏任务覆盖、边界情况描述不足
- **LOW**：文字风格优化、对执行顺序无影响的轻微冗余

### 6. 输出精炼分析报告

以 Markdown 形式输出报告（不得写入文件），结构如下：

## 规格分析报告

| ID | Category | Severity | Location(s) | Summary | Recommendation |
|----|----------|----------|-------------|---------|----------------|
| A1 | Duplication | HIGH | spec.md:L120-134 | 两条需求描述几乎相同…… | 合并表述，保留更清晰版本 |

（每个发现对应一行，ID 以分类首字母作为前缀并保持稳定。）

**覆盖率汇总表：**

| Requirement Key | Has Task? | Task IDs | Notes |
|-----------------|-----------|----------|-------|

**宪章对齐问题：**（如存在）

**未映射任务：**（如存在）

**指标：**

- 总需求数
- 总任务数
- 覆盖率（拥有 ≥1 个任务的需求占比）
- 歧义计数
- 重复计数
- Critical 问题数量

### 7. 给出后续行动

在报告末尾附上一段简洁的 Next Actions：

- 若存在 CRITICAL 问题：建议在运行 `/speckit.implement` 前先行解决
- 若仅有 LOW/MEDIUM：可继续推进，但需提供改进建议
- 给出明确的命令提示，例如：“运行 /speckit.specify 以细化规格”、“运行 /speckit.plan 调整架构”、“手动编辑 tasks.md 为 'performance-metrics' 添加覆盖”

### 8. 提供整改提议

向用户询问：“需要我为最重要的 N 个问题提供具体的整改建议吗？”（切勿自动应用这些修改。）

## 运行原则

### 上下文效率

- **尽量使用高信息密度的 Token**：聚焦可执行的发现，而非罗列全部细节
- **渐进式披露**：按需逐步加载文档，避免一次性倾倒内容
- **控制输出 Token**：发现表最多 50 行，超出部分合并总结
- **结果可重复**：无变更情况下再次运行应得出一致的 ID 与统计

### 分析准则

- **绝不修改文件**（本命令仅做分析）
- **绝不臆造缺失章节**（若确实缺失，请如实报告）
- **优先处理宪章冲突**（此类问题一律视为 CRITICAL）
- **以实例佐证而非泛泛而谈**（引用具体位置而非笼统规则）
- **在零问题时也要优雅收尾**（输出成功报告并附覆盖统计）

## 上下文

$ARGUMENTS
